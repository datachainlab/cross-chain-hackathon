/*
 * cross-chain-hackathon api
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"database/sql"
	"encoding/json"
	"log"

	"github.com/datachainlab/cross-chain-hackathon/backend/apiserver/rdb"
	"github.com/jmoiron/sqlx"
)

// TradeApiService is a service that implents the logic for the TradeApiServicer
// This service should implement the business logic for every endpoint for the TradeApi API.
// Include any external packages or services that will be required by this service.
type TradeApiService struct {
}

// NewTradeApiService creates a default api service
func NewTradeApiService() TradeApiServicer {
	return &TradeApiService{}
}

// DeleteTrade - cancel a trade
func (s *TradeApiService) DeleteTrade(id int64) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}
	q := `UPDATE trade SET status = ? WHERE id = ?`
	if _, err := db.Exec(q, TRADE_CANCELED, id); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}

	t := &Trade{}
	q = `SELECT id, estateId, unitPrice, amount, buyer, seller, type, status, updatedAt FROM trade WHERE id = ?`
	row := db.QueryRow(q, id)
	var buyer sql.NullString
	if err := row.Scan(&t.Id, &t.EstateId, &t.UnitPrice, &t.Amount, &buyer, &t.Seller, &t.Type, &t.Status, &t.UpdatedAt); err != nil {
		log.Println(err)
		return nil, err
	}
	if buyer.Valid {
		t.Buyer = buyer.String
	}
	return t, nil
}

// DeleteTradeRequest - cancel a trade request
func (s *TradeApiService) DeleteTradeRequest(id int64) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}
	q := `UPDATE trade_request SET status = ? WHERE id = ?`
	if _, err := db.Exec(q, REQUEST_CANCELED, id); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}

	tr := &TradeRequest{}
	q = `SELECT id, tradeId, "from", crossTx, status, updatedAt FROM trade_request WHERE id = ?`
	row := db.QueryRow(q, id)
	j := []byte{}
	if err := row.Scan(&tr.Id, &tr.TradeId, &tr.From, &j, &tr.Status, &tr.UpdatedAt); err != nil {
		log.Println(err)
		return nil, err
	}
	if err := json.Unmarshal(j, &tr.CrossTx); err != nil {
		log.Println(err)
		return nil, err
	}
	return tr, nil
}

// PostTrade - post a new sell offer
func (s *TradeApiService) PostTrade(trade Trade) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}

	q := `INSERT INTO trade(estateId, unitPrice, amount, seller, type) values(?, ?, ?, ?, ?)`
	if _, err := db.Exec(q, trade.EstateId, trade.UnitPrice, trade.Amount, trade.Seller, trade.Type); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}

	res := &Trade{}
	if err := db.Get(res, "select id, estateId, unitPrice, amount, seller, type, updatedAt from trade where rowid = last_insert_rowid()"); err != nil {
		log.Println(err)
		return nil, err
	}
	return res, nil
}

// PostTradeRequest - post a new trade request
func (s *TradeApiService) PostTradeRequest(in PostTradeRequestInput) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}

	j, err := json.Marshal(in.CrossTx)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	log.Println(string(j))

	q := `INSERT INTO trade_request(tradeId, "from", crossTx) values(?, ?, ?)`
	if _, err := db.Exec(q, in.TradeId, in.From, string(j)); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}

	res := &TradeRequest{}
	q = `select id, tradeId, "from", status, updatedAt from trade_request where rowid = last_insert_rowid()`
	if err := db.Get(res, q); err != nil {
		log.Println(err)
		return nil, err
	}
	res.CrossTx = in.CrossTx
	return res, nil
}

func SelectOngoingTradeRequest(db *sqlx.DB) ([]TradeRequest, error) {
	// status 0 = OPENED, 2 = ONGOING
	q := `SELECT id, tradeId, crossTx, status FROM trade_request WHERE status IN (0, 2)`
	rows, err := db.Query(q)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	trs := []TradeRequest{}
	for rows.Next() {
		tr := TradeRequest{}
		j := []byte{}
		if err := rows.Scan(&tr.Id, &tr.TradeId, &j, &tr.Status); err != nil {
			log.Println(err)
			return nil, err
		}
		if err := json.Unmarshal(j, &tr.CrossTx); err != nil {
			log.Println(err)
			return nil, err
		}
		trs = append(trs, tr)
	}
	return trs, nil
}

func UpdateTradeRequestStatus(db *sqlx.DB, tr TradeRequest) error {
	// transaction
	tx, err := db.Begin()
	if err != nil {
		log.Println(err)
		return err
	}

	q := `UPDATE trade_request SET status = ? WHERE id = ?`
	if _, err := tx.Exec(q, tr.Status, tr.Id); err != nil {
		log.Println(err)
		if err = tx.Rollback(); err != nil {
			log.Println(err)
			return err
		}
		return ErrorFailedDBSet
	}

	// if status is completed, then update also the trade
	if tr.Status == REQUEST_COMPLETED {
		q = `UPDATE trade SET status = ?, buyer = ? WHERE id = ?`
		if _, err := tx.Exec(q, TRADE_COMPLETED, tr.From, tr.TradeId); err != nil {
			log.Println(err)
			if err = tx.Rollback(); err != nil {
				log.Println(err)
				return err
			}
			return ErrorFailedDBSet
		}
	}

	if err = tx.Commit(); err != nil {
		log.Println(err)
		return err
	}
	return nil
}
