/*
 * cross-chain-hackathon api
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"database/sql"
	"encoding/json"
	"log"

	"github.com/datachainlab/cross-chain-hackathon/backend/apiserver/rdb"
)

// TradeApiService is a service that implents the logic for the TradeApiServicer
// This service should implement the business logic for every endpoint for the TradeApi API.
// Include any external packages or services that will be required by this service.
type TradeApiService struct {
}

// NewTradeApiService creates a default api service
func NewTradeApiService() TradeApiServicer {
	return &TradeApiService{}
}

// DeleteTrade - cancel a trade
func (s *TradeApiService) DeleteTrade(id int64) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}
	q := `UPDATE trade SET status = ? WHERE id = ?`
	if _, err := db.Exec(q, TRADE_CANCELED, id); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}
	trade := &Trade{}
	q = `SELECT * FROM trade WHERE id = ?`
	if err := db.Get(trade, q, id); err != nil {
		return nil, err
	}
	return trade, nil
}

// DeleteTradeRequest - cancel a trade request
func (s *TradeApiService) DeleteTradeRequest(id int64) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}
	q := `UPDATE tradeRequest SET status = ? WHERE id = ?`
	if _, err := db.Exec(q, REQUEST_CANCELED, id); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}
	tr := &TradeRequest{}
	q = `SELECT * FROM tradeRequest WHERE id = ?`
	if err := db.Get(tr, q, id); err != nil {
		return nil, err
	}
	return tr, nil
}

// PostTrade - post a new sell offer
func (s *TradeApiService) PostTrade(trade Trade) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}

	q := `INSERT INTO trade(estateId, unitPrice, amount, seller, type) values(?, ?, ?, ?, ?)`
	if _, err := db.Exec(q, trade.EstateId, trade.UnitPrice, trade.Amount, trade.Seller, trade.Type); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}

	res := &Trade{}
	if err := db.Get(res, "select id, estateId, unitPrice, amount, seller, type, updatedAt from trade where rowid = last_insert_rowid()"); err != nil {
		return nil, err
	}
	return res, nil
}

// PostTradeRequest - post a new trade request
func (s *TradeApiService) PostTradeRequest(in PostTradeRequestInput) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}

	j, err := json.Marshal(in.CrossTx)
	if err != nil {
		return nil, err
	}
	log.Println(string(j))

	q := `INSERT INTO trade_request(tradeId, "from", crossTx) values(?, ?, ?)`
	if _, err := db.Exec(q, in.TradeId, in.From, string(j)); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}

	res := &TradeRequest{}
	q = `select id, tradeId, "from", status, updatedAt from trade_request where rowid = last_insert_rowid()`
	if err := db.Get(res, q); err != nil {
		return nil, err
	}
	res.CrossTx = in.CrossTx
	return res, nil
}

// PutTrade - update a trade request (mainly for updating status)
func (s *TradeApiService) PutTrade(trade Trade) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}

	var status TradeStatus
	q := `SELECT status from trade WHERE id = ?`
	if err := db.Get(&status, q, trade.Id); err != nil {
		return nil, err
	}
	if status != TRADE_OPENED {
		return nil, ErrorWrongStatus
	}

	// only status is updated
	q = `UPDATE trade SET status = ? WHERE id = ?`
	if _, err := db.Exec(q, trade.Status, trade.Id); err != nil {
		log.Println(err)
		return nil, ErrorFailedDBSet
	}

	t := Trade{}
	var buyer sql.NullString
	q = `select id, estateId, unitPrice, amount, buyer, seller, type, status, updatedAt from trade where id = ?`
	row := db.QueryRow(q, trade.Id)
	if err := row.Scan(&t.Id, &t.EstateId, &t.UnitPrice, &t.Amount, &buyer, &t.Seller, &t.Type, &t.Status, &t.UpdatedAt); err != nil {
		return nil, err
	}
	if buyer.Valid {
		t.Buyer = buyer.String
	}
	return &t, nil
}

// PutTradeRequest - update a trade request (mainly for updating status)
func (s *TradeApiService) PutTradeRequest(tradeRequest TradeRequest) (interface{}, error) {
	db, err := rdb.InitDB()
	if err != nil {
		log.Println(err)
		return nil, ErrorFailedDBConnect
	}

	// get record at first
	tr := &TradeRequest{}
	q := `select id, tradeId, "from", status, updatedAt from trade_request where id = ?`
	if err := db.Get(tr, q, tradeRequest.Id); err != nil {
		return nil, err
	}

	if tr.Status != REQUEST_OPENED && tr.Status != REQUEST_ONGOING {
		return nil, ErrorWrongStatus
	}

	// transaction
	tx, err := db.Begin()
	if err != nil {
		return nil, err
	}

	log.Printf("request status: %d\n", tradeRequest.Status)
	q = `UPDATE trade_request SET status = ? WHERE id = ?`
	if _, err := tx.Exec(q, tradeRequest.Status, tradeRequest.Id); err != nil {
		log.Println(err)
		if err = tx.Rollback(); err != nil {
			// HACK
			return nil, err
		}
		return nil, ErrorFailedDBSet
	}

	// if status is completed, then update also the trade
	if tradeRequest.Status == REQUEST_COMPLETED {
		q = `UPDATE trade SET status = ?, buyer = ? WHERE id = ?`
		if _, err := tx.Exec(q, TRADE_COMPLETED, tr.From, tr.TradeId); err != nil {
			log.Println(err)
			if err = tx.Rollback(); err != nil {
				// HACK
				return nil, err
			}
			return nil, ErrorFailedDBSet
		}
	}

	if err = tx.Commit(); err != nil {
		// HACK
		return nil, err
	}
	return &tradeRequest, nil
}
