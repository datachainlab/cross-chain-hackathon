// tslint:disable
/**
 * cross-chain-hackathon api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * defined by cross
 * @export
 * @interface ChannelInfo
 */
export interface ChannelInfo {
    /**
     * 
     * @type {string}
     * @memberof ChannelInfo
     */
    port: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelInfo
     */
    channel: string;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    denom?: string;
    /**
     * 
     * @type {number}
     * @memberof Coin
     */
    amount: number;
}
/**
 * 
 * @export
 * @interface ContractTransaction
 */
export interface ContractTransaction {
    /**
     * 
     * @type {ChannelInfo}
     * @memberof ContractTransaction
     */
    source: ChannelInfo;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractTransaction
     */
    signers: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ContractTransaction
     */
    contract: string;
    /**
     * 
     * @type {Array<Op>}
     * @memberof ContractTransaction
     */
    ops: Array<Op>;
}
/**
 * 
 * @export
 * @interface CrossTx
 */
export interface CrossTx {
    /**
     * 
     * @type {string}
     * @memberof CrossTx
     */
    type: string;
    /**
     * 
     * @type {StdTx}
     * @memberof CrossTx
     */
    value: StdTx;
}
/**
 * 
 * @export
 * @interface Estate
 */
export interface Estate {
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    tokenId: string;
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    imagePath: string;
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    description: string;
    /**
     * public offering price
     * @type {number}
     * @memberof Estate
     */
    offerPrice: number;
    /**
     * expected yield amount per share
     * @type {number}
     * @memberof Estate
     */
    expectedYield: number;
    /**
     * next dividend date
     * @type {string}
     * @memberof Estate
     */
    dividendDate: string;
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    issuedBy: string;
}
/**
 * for frontend\'s convenience
 * @export
 * @interface GetEstateOutput
 */
export interface GetEstateOutput {
    /**
     * 
     * @type {Estate}
     * @memberof GetEstateOutput
     */
    estate: Estate;
    /**
     * 
     * @type {Array<Trade>}
     * @memberof GetEstateOutput
     */
    trades: Array<Trade>;
}
/**
 * for MsgInitiate
 * @export
 * @interface Msg
 */
export interface Msg {
    /**
     * 
     * @type {string}
     * @memberof Msg
     */
    type: string;
    /**
     * 
     * @type {MsgInitiate}
     * @memberof Msg
     */
    value: MsgInitiate;
}
/**
 * a message type defined by cross
 * @export
 * @interface MsgInitiate
 */
export interface MsgInitiate {
    /**
     * 
     * @type {string}
     * @memberof MsgInitiate
     */
    Sender: string;
    /**
     * 
     * @type {string}
     * @memberof MsgInitiate
     */
    ChainID: string;
    /**
     * 
     * @type {Array<ContractTransaction>}
     * @memberof MsgInitiate
     */
    ContractTransactions: Array<ContractTransaction>;
    /**
     * 
     * @type {string}
     * @memberof MsgInitiate
     */
    TimeoutHeight: string;
    /**
     * 
     * @type {string}
     * @memberof MsgInitiate
     */
    Nonce: string;
}
/**
 * 
 * @export
 * @interface Op
 */
export interface Op {
    /**
     * 
     * @type {string}
     * @memberof Op
     */
    type: string;
    /**
     * 
     * @type {OpValue}
     * @memberof Op
     */
    value: OpValue;
}
/**
 * Write(K, V) or Read(K)
 * @export
 * @interface OpValue
 */
export interface OpValue {
    /**
     * 
     * @type {string}
     * @memberof OpValue
     */
    K: string;
    /**
     * 
     * @type {string}
     * @memberof OpValue
     */
    V?: string;
}
/**
 * 
 * @export
 * @interface PostTradeRequestInput
 */
export interface PostTradeRequestInput {
    /**
     * generated by the API server
     * @type {number}
     * @memberof PostTradeRequestInput
     */
    tradeId: number;
    /**
     * 
     * @type {string}
     * @memberof PostTradeRequestInput
     */
    from: string;
    /**
     * 
     * @type {CrossTx}
     * @memberof PostTradeRequestInput
     */
    crossTx: CrossTx;
}
/**
 * 
 * @export
 * @interface StdFee
 */
export interface StdFee {
    /**
     * 
     * @type {Array<Coin>}
     * @memberof StdFee
     */
    amount: Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof StdFee
     */
    gas: string;
}
/**
 * 
 * @export
 * @interface StdSignature
 */
export interface StdSignature {
    /**
     * 
     * @type {string}
     * @memberof StdSignature
     */
    pub_key?: string;
    /**
     * 
     * @type {string}
     * @memberof StdSignature
     */
    signature: string;
}
/**
 * same as cosmos sdk
 * @export
 * @interface StdTx
 */
export interface StdTx {
    /**
     * 
     * @type {Array<Msg>}
     * @memberof StdTx
     */
    msg: Array<Msg>;
    /**
     * 
     * @type {StdFee}
     * @memberof StdTx
     */
    fee: StdFee;
    /**
     * 
     * @type {Array<StdSignature>}
     * @memberof StdTx
     */
    signatures?: Array<StdSignature>;
    /**
     * 
     * @type {string}
     * @memberof StdTx
     */
    memo: string;
}
/**
 * 
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * generated by the API server
     * @type {number}
     * @memberof Trade
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    estateId: string;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    unitPrice: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    seller: string;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    type: TradeTypeEnum;
    /**
     * 
     * @type {Array<TradeRequest>}
     * @memberof Trade
     */
    requests: Array<TradeRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof Trade
     */
    canceled: boolean;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    updatedAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TradeTypeEnum {
    Buy = 'buy',
    Sell = 'sell'
}

/**
 * 
 * @export
 * @interface TradeRequest
 */
export interface TradeRequest {
    /**
     * generated by the API server
     * @type {number}
     * @memberof TradeRequest
     */
    id: number;
    /**
     * generated by the API server
     * @type {number}
     * @memberof TradeRequest
     */
    tradeId: number;
    /**
     * 
     * @type {string}
     * @memberof TradeRequest
     */
    from: string;
    /**
     * 
     * @type {CrossTx}
     * @memberof TradeRequest
     */
    crossTx: CrossTx;
    /**
     * 
     * @type {boolean}
     * @memberof TradeRequest
     */
    canceled: boolean;
    /**
     * 
     * @type {string}
     * @memberof TradeRequest
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    mnemonic: string;
}

/**
 * EstateApi - axios parameter creator
 * @export
 */
export const EstateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get an estate and its trade data
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstateById: async (estateId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'estateId' is not null or undefined
            if (estateId === null || estateId === undefined) {
                throw new RequiredError('estateId','Required parameter estateId was null or undefined when calling getEstateById.');
            }
            const localVarPath = `/estate/{estateId}`
                .replace(`{${"estateId"}}`, encodeURIComponent(String(estateId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all estates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstates: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/estates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EstateApi - functional programming interface
 * @export
 */
export const EstateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get an estate and its trade data
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEstateById(estateId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEstateOutput>> {
            const localVarAxiosArgs = await EstateApiAxiosParamCreator(configuration).getEstateById(estateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all estates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEstates(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Estate>>> {
            const localVarAxiosArgs = await EstateApiAxiosParamCreator(configuration).getEstates(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EstateApi - factory interface
 * @export
 */
export const EstateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get an estate and its trade data
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstateById(estateId: string, options?: any): AxiosPromise<GetEstateOutput> {
            return EstateApiFp(configuration).getEstateById(estateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all estates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstates(options?: any): AxiosPromise<Array<Estate>> {
            return EstateApiFp(configuration).getEstates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EstateApi - object-oriented interface
 * @export
 * @class EstateApi
 * @extends {BaseAPI}
 */
export class EstateApi extends BaseAPI {
    /**
     * 
     * @summary get an estate and its trade data
     * @param {string} estateId query target estate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstateApi
     */
    public getEstateById(estateId: string, options?: any) {
        return EstateApiFp(this.configuration).getEstateById(estateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all estates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstateApi
     */
    public getEstates(options?: any) {
        return EstateApiFp(this.configuration).getEstates(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cancel a trade
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrade: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTrade.');
            }
            const localVarPath = `/trade/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTradeRequest: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTradeRequest.');
            }
            const localVarPath = `/trade/request/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post a new sell offer
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrade: async (trade?: Trade, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/trades`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof trade !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(trade !== undefined ? trade : {}) : (trade || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post a new trade request
         * @param {PostTradeRequestInput} [postTradeRequestInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTradeRequest: async (postTradeRequestInput?: PostTradeRequestInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/trade/requests`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postTradeRequestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postTradeRequestInput !== undefined ? postTradeRequestInput : {}) : (postTradeRequestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cancel a trade
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrade(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).deleteTrade(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary cancel a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTradeRequest(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeRequest>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).deleteTradeRequest(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary post a new sell offer
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTrade(trade?: Trade, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).postTrade(trade, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary post a new trade request
         * @param {PostTradeRequestInput} [postTradeRequestInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTradeRequest(postTradeRequestInput?: PostTradeRequestInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeRequest>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).postTradeRequest(postTradeRequestInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary cancel a trade
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrade(id: number, options?: any): AxiosPromise<Trade> {
            return TradeApiFp(configuration).deleteTrade(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTradeRequest(id: number, options?: any): AxiosPromise<TradeRequest> {
            return TradeApiFp(configuration).deleteTradeRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary post a new sell offer
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrade(trade?: Trade, options?: any): AxiosPromise<Trade> {
            return TradeApiFp(configuration).postTrade(trade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary post a new trade request
         * @param {PostTradeRequestInput} [postTradeRequestInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTradeRequest(postTradeRequestInput?: PostTradeRequestInput, options?: any): AxiosPromise<TradeRequest> {
            return TradeApiFp(configuration).postTradeRequest(postTradeRequestInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI {
    /**
     * 
     * @summary cancel a trade
     * @param {number} id trade id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public deleteTrade(id: number, options?: any) {
        return TradeApiFp(this.configuration).deleteTrade(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel a trade request
     * @param {number} id trade request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public deleteTradeRequest(id: number, options?: any) {
        return TradeApiFp(this.configuration).deleteTradeRequest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary post a new sell offer
     * @param {Trade} [trade] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public postTrade(trade?: Trade, options?: any) {
        return TradeApiFp(this.configuration).postTrade(trade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary post a new trade request
     * @param {PostTradeRequestInput} [postTradeRequestInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public postTradeRequest(postTradeRequestInput?: PostTradeRequestInput, options?: any) {
        return TradeApiFp(this.configuration).postTradeRequest(postTradeRequestInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TxApi - axios parameter creator
 * @export
 */
export const TxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {string} estateId 
         * @param {number} perShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txDividendGet: async (estateId: string, perShare: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'estateId' is not null or undefined
            if (estateId === null || estateId === undefined) {
                throw new RequiredError('estateId','Required parameter estateId was null or undefined when calling txDividendGet.');
            }
            // verify required parameter 'perShare' is not null or undefined
            if (perShare === null || perShare === undefined) {
                throw new RequiredError('perShare','Required parameter perShare was null or undefined when calling txDividendGet.');
            }
            const localVarPath = `/tx/dividend`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (estateId !== undefined) {
                localVarQueryParameter['estateId'] = estateId;
            }

            if (perShare !== undefined) {
                localVarQueryParameter['perShare'] = perShare;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {number} tradeId 
         * @param {string} from 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txTradeRequestGet: async (tradeId: number, from: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tradeId' is not null or undefined
            if (tradeId === null || tradeId === undefined) {
                throw new RequiredError('tradeId','Required parameter tradeId was null or undefined when calling txTradeRequestGet.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling txTradeRequestGet.');
            }
            const localVarPath = `/tx/trade/request`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tradeId !== undefined) {
                localVarQueryParameter['tradeId'] = tradeId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TxApi - functional programming interface
 * @export
 */
export const TxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {string} estateId 
         * @param {number} perShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txDividendGet(estateId: string, perShare: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossTx>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).txDividendGet(estateId, perShare, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {number} tradeId 
         * @param {string} from 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txTradeRequestGet(tradeId: number, from: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossTx>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).txTradeRequestGet(tradeId, from, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TxApi - factory interface
 * @export
 */
export const TxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {string} estateId 
         * @param {number} perShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txDividendGet(estateId: string, perShare: number, options?: any): AxiosPromise<CrossTx> {
            return TxApiFp(configuration).txDividendGet(estateId, perShare, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {number} tradeId 
         * @param {string} from 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txTradeRequestGet(tradeId: number, from: string, options?: any): AxiosPromise<CrossTx> {
            return TxApiFp(configuration).txTradeRequestGet(tradeId, from, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TxApi - object-oriented interface
 * @export
 * @class TxApi
 * @extends {BaseAPI}
 */
export class TxApi extends BaseAPI {
    /**
     * 
     * @summary get a CrossTx to be signed
     * @param {string} estateId 
     * @param {number} perShare 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public txDividendGet(estateId: string, perShare: number, options?: any) {
        return TxApiFp(this.configuration).txDividendGet(estateId, perShare, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a CrossTx to be signed
     * @param {number} tradeId 
     * @param {string} from 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public txTradeRequestGet(tradeId: number, from: string, options?: any) {
        return TxApiFp(this.configuration).txTradeRequestGet(tradeId, from, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get user information
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUser.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get user information
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUsers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get user information
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): AxiosPromise<Array<User>> {
            return UserApiFp(configuration).getUsers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary get user information
     * @param {string} id user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(id: string, options?: any) {
        return UserApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(options?: any) {
        return UserApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

}


