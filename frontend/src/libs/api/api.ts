// tslint:disable
/**
 * cross-chain-hackathon api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * defined by cross
 * @export
 * @interface ChannelInfo
 */
export interface ChannelInfo {
    /**
     * 
     * @type {string}
     * @memberof ChannelInfo
     */
    port: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelInfo
     */
    channel: string;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    denom?: string;
    /**
     * 
     * @type {number}
     * @memberof Coin
     */
    amount: number;
}
/**
 * 
 * @export
 * @interface ContractTransaction
 */
export interface ContractTransaction {
    /**
     * 
     * @type {ChannelInfo}
     * @memberof ContractTransaction
     */
    source: ChannelInfo;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractTransaction
     */
    signers: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ContractTransaction
     */
    contract: string;
    /**
     * 
     * @type {Array<Op>}
     * @memberof ContractTransaction
     */
    ops: Array<Op>;
}
/**
 * 
 * @export
 * @interface CrossTx
 */
export interface CrossTx {
    /**
     * 
     * @type {string}
     * @memberof CrossTx
     */
    type: string;
    /**
     * 
     * @type {StdTx}
     * @memberof CrossTx
     */
    value: StdTx;
}
/**
 * 
 * @export
 * @interface Dividend
 */
export interface Dividend {
    /**
     * for primary key
     * @type {number}
     * @memberof Dividend
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Dividend
     */
    estateId: string;
    /**
     * this is determined by the contract
     * @type {number}
     * @memberof Dividend
     */
    index?: number;
    /**
     * 
     * @type {number}
     * @memberof Dividend
     */
    perShare: number;
    /**
     * 
     * @type {CrossTx}
     * @memberof Dividend
     */
    crossTx: CrossTx;
    /**
     * 
     * @type {DividendStatus}
     * @memberof Dividend
     */
    status: DividendStatus;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DividendStatus {
    DIVIDEND_REGISTERED = 0,
    DIVIDEND_ONGOING = 1,
    DIVIDEND_COMPLETED = 2,
    DIVIDEND_FAILED = 3
}

/**
 * 
 * @export
 * @interface Estate
 */
export interface Estate {
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    tokenId: string;
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    imagePath: string;
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    description: string;
    /**
     * public offering price
     * @type {number}
     * @memberof Estate
     */
    offerPrice: number;
    /**
     * expected yield amount per share
     * @type {number}
     * @memberof Estate
     */
    expectedYield: number;
    /**
     * next dividend date
     * @type {string}
     * @memberof Estate
     */
    dividendDate: string;
    /**
     * 
     * @type {string}
     * @memberof Estate
     */
    issuedBy: string;
    /**
     * 
     * @type {Array<Trade>}
     * @memberof Estate
     */
    trades: Array<Trade>;
}
/**
 * for MsgInitiate
 * @export
 * @interface Msg
 */
export interface Msg {
    /**
     * 
     * @type {string}
     * @memberof Msg
     */
    type: string;
    /**
     * 
     * @type {MsgInitiate}
     * @memberof Msg
     */
    value: MsgInitiate;
}
/**
 * a message type defined by cross
 * @export
 * @interface MsgInitiate
 */
export interface MsgInitiate {
    /**
     * 
     * @type {string}
     * @memberof MsgInitiate
     */
    Sender: string;
    /**
     * 
     * @type {string}
     * @memberof MsgInitiate
     */
    ChainID: string;
    /**
     * 
     * @type {Array<ContractTransaction>}
     * @memberof MsgInitiate
     */
    ContractTransactions: Array<ContractTransaction>;
    /**
     * 
     * @type {string}
     * @memberof MsgInitiate
     */
    TimeoutHeight: string;
    /**
     * 
     * @type {string}
     * @memberof MsgInitiate
     */
    Nonce: string;
}
/**
 * 
 * @export
 * @interface Op
 */
export interface Op {
    /**
     * 
     * @type {string}
     * @memberof Op
     */
    type: string;
    /**
     * 
     * @type {OpValue}
     * @memberof Op
     */
    value: OpValue;
}
/**
 * Write(K, V) or Read(K)
 * @export
 * @interface OpValue
 */
export interface OpValue {
    /**
     * 
     * @type {string}
     * @memberof OpValue
     */
    K: string;
    /**
     * 
     * @type {string}
     * @memberof OpValue
     */
    V?: string;
}
/**
 * 
 * @export
 * @interface PostTradeRequestInput
 */
export interface PostTradeRequestInput {
    /**
     * generated by the API server
     * @type {number}
     * @memberof PostTradeRequestInput
     */
    tradeId: number;
    /**
     * 
     * @type {string}
     * @memberof PostTradeRequestInput
     */
    from: string;
    /**
     * 
     * @type {CrossTx}
     * @memberof PostTradeRequestInput
     */
    crossTx: CrossTx;
}
/**
 * 
 * @export
 * @interface StdFee
 */
export interface StdFee {
    /**
     * 
     * @type {Array<Coin>}
     * @memberof StdFee
     */
    amount: Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof StdFee
     */
    gas: string;
}
/**
 * 
 * @export
 * @interface StdSignature
 */
export interface StdSignature {
    /**
     * 
     * @type {string}
     * @memberof StdSignature
     */
    pub_key?: string;
    /**
     * 
     * @type {string}
     * @memberof StdSignature
     */
    signature: string;
}
/**
 * same as cosmos sdk
 * @export
 * @interface StdTx
 */
export interface StdTx {
    /**
     * 
     * @type {Array<Msg>}
     * @memberof StdTx
     */
    msg: Array<Msg>;
    /**
     * 
     * @type {StdFee}
     * @memberof StdTx
     */
    fee: StdFee;
    /**
     * 
     * @type {Array<StdSignature>}
     * @memberof StdTx
     */
    signatures?: Array<StdSignature>;
    /**
     * 
     * @type {string}
     * @memberof StdTx
     */
    memo: string;
}
/**
 * 
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * generated by the API server
     * @type {number}
     * @memberof Trade
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    estateId: string;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    unitPrice: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    seller: string;
    /**
     * 
     * @type {TradeType}
     * @memberof Trade
     */
    type: TradeType;
    /**
     * 
     * @type {Array<TradeRequest>}
     * @memberof Trade
     */
    requests: Array<TradeRequest>;
    /**
     * 
     * @type {TradeStatus}
     * @memberof Trade
     */
    status: TradeStatus;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TradeRequest
 */
export interface TradeRequest {
    /**
     * generated by the API server
     * @type {number}
     * @memberof TradeRequest
     */
    id: number;
    /**
     * generated by the API server
     * @type {number}
     * @memberof TradeRequest
     */
    tradeId: number;
    /**
     * 
     * @type {string}
     * @memberof TradeRequest
     */
    from: string;
    /**
     * 
     * @type {CrossTx}
     * @memberof TradeRequest
     */
    crossTx: CrossTx;
    /**
     * 
     * @type {TradeRequestStatus}
     * @memberof TradeRequest
     */
    status: TradeRequestStatus;
    /**
     * 
     * @type {string}
     * @memberof TradeRequest
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TradeRequestStatus {
    REQUEST_OPENED = 0,
    REQUEST_CANCELED = 1,
    REQUEST_ONGOING = 2,
    REQUEST_COMPLETED = 3,
    REQUEST_FAILED = 4
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TradeStatus {
    TRADE_OPENED = 0,
    TRADE_CANCELED = 1,
    TRADE_COMPLETED = 2
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TradeType {
    BUY = 0,
    SELL = 1
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    mnemonic: string;
}

/**
 * DividendApi - axios parameter creator
 * @export
 */
export const DividendApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get the dividends of an estate token
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDividendsByEstateId: async (estateId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'estateId' is not null or undefined
            if (estateId === null || estateId === undefined) {
                throw new RequiredError('estateId','Required parameter estateId was null or undefined when calling getDividendsByEstateId.');
            }
            const localVarPath = `/dividends/{estateId}`
                .replace(`{${"estateId"}}`, encodeURIComponent(String(estateId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DividendApi - functional programming interface
 * @export
 */
export const DividendApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get the dividends of an estate token
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDividendsByEstateId(estateId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dividend>>> {
            const localVarAxiosArgs = await DividendApiAxiosParamCreator(configuration).getDividendsByEstateId(estateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DividendApi - factory interface
 * @export
 */
export const DividendApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get the dividends of an estate token
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDividendsByEstateId(estateId: string, options?: any): AxiosPromise<Array<Dividend>> {
            return DividendApiFp(configuration).getDividendsByEstateId(estateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DividendApi - object-oriented interface
 * @export
 * @class DividendApi
 * @extends {BaseAPI}
 */
export class DividendApi extends BaseAPI {
    /**
     * 
     * @summary get the dividends of an estate token
     * @param {string} estateId query target estate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DividendApi
     */
    public getDividendsByEstateId(estateId: string, options?: any) {
        return DividendApiFp(this.configuration).getDividendsByEstateId(estateId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EstateApi - axios parameter creator
 * @export
 */
export const EstateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get an estate and its trade data
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstateById: async (estateId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'estateId' is not null or undefined
            if (estateId === null || estateId === undefined) {
                throw new RequiredError('estateId','Required parameter estateId was null or undefined when calling getEstateById.');
            }
            const localVarPath = `/estate/{estateId}`
                .replace(`{${"estateId"}}`, encodeURIComponent(String(estateId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all estates and their associated trades and requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstates: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/estates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EstateApi - functional programming interface
 * @export
 */
export const EstateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get an estate and its trade data
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEstateById(estateId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Estate>> {
            const localVarAxiosArgs = await EstateApiAxiosParamCreator(configuration).getEstateById(estateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all estates and their associated trades and requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEstates(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Estate>>> {
            const localVarAxiosArgs = await EstateApiAxiosParamCreator(configuration).getEstates(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EstateApi - factory interface
 * @export
 */
export const EstateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get an estate and its trade data
         * @param {string} estateId query target estate id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstateById(estateId: string, options?: any): AxiosPromise<Estate> {
            return EstateApiFp(configuration).getEstateById(estateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all estates and their associated trades and requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstates(options?: any): AxiosPromise<Array<Estate>> {
            return EstateApiFp(configuration).getEstates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EstateApi - object-oriented interface
 * @export
 * @class EstateApi
 * @extends {BaseAPI}
 */
export class EstateApi extends BaseAPI {
    /**
     * 
     * @summary get an estate and its trade data
     * @param {string} estateId query target estate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstateApi
     */
    public getEstateById(estateId: string, options?: any) {
        return EstateApiFp(this.configuration).getEstateById(estateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all estates and their associated trades and requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstateApi
     */
    public getEstates(options?: any) {
        return EstateApiFp(this.configuration).getEstates(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cancel a trade
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrade: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTrade.');
            }
            const localVarPath = `/trade/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTradeRequest: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTradeRequest.');
            }
            const localVarPath = `/trade_request/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a trade with requests
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTradeById.');
            }
            const localVarPath = `/trade/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeRequestById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTradeRequestById.');
            }
            const localVarPath = `/trade_request/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get requests by user id and status
         * @param {string} userId user id
         * @param {TradeStatus} tradeStatus trade status
         * @param {TradeRequestStatus} tradeRequestStatus trade request status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeRequestsByUserId: async (userId: string, tradeStatus: TradeStatus, tradeRequestStatus: TradeRequestStatus, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getTradeRequestsByUserId.');
            }
            // verify required parameter 'tradeStatus' is not null or undefined
            if (tradeStatus === null || tradeStatus === undefined) {
                throw new RequiredError('tradeStatus','Required parameter tradeStatus was null or undefined when calling getTradeRequestsByUserId.');
            }
            // verify required parameter 'tradeRequestStatus' is not null or undefined
            if (tradeRequestStatus === null || tradeRequestStatus === undefined) {
                throw new RequiredError('tradeRequestStatus','Required parameter tradeRequestStatus was null or undefined when calling getTradeRequestsByUserId.');
            }
            const localVarPath = `/trade_requests`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (tradeStatus !== undefined) {
                localVarQueryParameter['tradeStatus'] = tradeStatus;
            }

            if (tradeRequestStatus !== undefined) {
                localVarQueryParameter['tradeRequestStatus'] = tradeRequestStatus;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post a new sell offer
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrade: async (trade?: Trade, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/trades`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof trade !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(trade !== undefined ? trade : {}) : (trade || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post a new trade request
         * @param {PostTradeRequestInput} [postTradeRequestInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTradeRequest: async (postTradeRequestInput?: PostTradeRequestInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/trade_requests`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postTradeRequestInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postTradeRequestInput !== undefined ? postTradeRequestInput : {}) : (postTradeRequestInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cancel a trade
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrade(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).deleteTrade(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary cancel a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTradeRequest(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeRequest>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).deleteTradeRequest(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get a trade with requests
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).getTradeById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeRequestById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeRequest>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).getTradeRequestById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get requests by user id and status
         * @param {string} userId user id
         * @param {TradeStatus} tradeStatus trade status
         * @param {TradeRequestStatus} tradeRequestStatus trade request status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTradeRequestsByUserId(userId: string, tradeStatus: TradeStatus, tradeRequestStatus: TradeRequestStatus, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradeRequest>>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).getTradeRequestsByUserId(userId, tradeStatus, tradeRequestStatus, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary post a new sell offer
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTrade(trade?: Trade, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).postTrade(trade, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary post a new trade request
         * @param {PostTradeRequestInput} [postTradeRequestInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTradeRequest(postTradeRequestInput?: PostTradeRequestInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeRequest>> {
            const localVarAxiosArgs = await TradeApiAxiosParamCreator(configuration).postTradeRequest(postTradeRequestInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary cancel a trade
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrade(id: number, options?: any): AxiosPromise<Trade> {
            return TradeApiFp(configuration).deleteTrade(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTradeRequest(id: number, options?: any): AxiosPromise<TradeRequest> {
            return TradeApiFp(configuration).deleteTradeRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a trade with requests
         * @param {number} id trade id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeById(id: number, options?: any): AxiosPromise<Trade> {
            return TradeApiFp(configuration).getTradeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a trade request
         * @param {number} id trade request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeRequestById(id: number, options?: any): AxiosPromise<TradeRequest> {
            return TradeApiFp(configuration).getTradeRequestById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get requests by user id and status
         * @param {string} userId user id
         * @param {TradeStatus} tradeStatus trade status
         * @param {TradeRequestStatus} tradeRequestStatus trade request status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTradeRequestsByUserId(userId: string, tradeStatus: TradeStatus, tradeRequestStatus: TradeRequestStatus, options?: any): AxiosPromise<Array<TradeRequest>> {
            return TradeApiFp(configuration).getTradeRequestsByUserId(userId, tradeStatus, tradeRequestStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary post a new sell offer
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrade(trade?: Trade, options?: any): AxiosPromise<Trade> {
            return TradeApiFp(configuration).postTrade(trade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary post a new trade request
         * @param {PostTradeRequestInput} [postTradeRequestInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTradeRequest(postTradeRequestInput?: PostTradeRequestInput, options?: any): AxiosPromise<TradeRequest> {
            return TradeApiFp(configuration).postTradeRequest(postTradeRequestInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI {
    /**
     * 
     * @summary cancel a trade
     * @param {number} id trade id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public deleteTrade(id: number, options?: any) {
        return TradeApiFp(this.configuration).deleteTrade(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel a trade request
     * @param {number} id trade request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public deleteTradeRequest(id: number, options?: any) {
        return TradeApiFp(this.configuration).deleteTradeRequest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a trade with requests
     * @param {number} id trade id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public getTradeById(id: number, options?: any) {
        return TradeApiFp(this.configuration).getTradeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a trade request
     * @param {number} id trade request id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public getTradeRequestById(id: number, options?: any) {
        return TradeApiFp(this.configuration).getTradeRequestById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get requests by user id and status
     * @param {string} userId user id
     * @param {TradeStatus} tradeStatus trade status
     * @param {TradeRequestStatus} tradeRequestStatus trade request status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public getTradeRequestsByUserId(userId: string, tradeStatus: TradeStatus, tradeRequestStatus: TradeRequestStatus, options?: any) {
        return TradeApiFp(this.configuration).getTradeRequestsByUserId(userId, tradeStatus, tradeRequestStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary post a new sell offer
     * @param {Trade} [trade] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public postTrade(trade?: Trade, options?: any) {
        return TradeApiFp(this.configuration).postTrade(trade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary post a new trade request
     * @param {PostTradeRequestInput} [postTradeRequestInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public postTradeRequest(postTradeRequestInput?: PostTradeRequestInput, options?: any) {
        return TradeApiFp(this.configuration).postTradeRequest(postTradeRequestInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TxApi - axios parameter creator
 * @export
 */
export const TxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {string} estateId 
         * @param {number} perShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxDividend: async (estateId: string, perShare: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'estateId' is not null or undefined
            if (estateId === null || estateId === undefined) {
                throw new RequiredError('estateId','Required parameter estateId was null or undefined when calling getTxDividend.');
            }
            // verify required parameter 'perShare' is not null or undefined
            if (perShare === null || perShare === undefined) {
                throw new RequiredError('perShare','Required parameter perShare was null or undefined when calling getTxDividend.');
            }
            const localVarPath = `/tx/dividend`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (estateId !== undefined) {
                localVarQueryParameter['estateId'] = estateId;
            }

            if (perShare !== undefined) {
                localVarQueryParameter['perShare'] = perShare;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {number} tradeId 
         * @param {string} from 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxTradeRequest: async (tradeId: number, from: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tradeId' is not null or undefined
            if (tradeId === null || tradeId === undefined) {
                throw new RequiredError('tradeId','Required parameter tradeId was null or undefined when calling getTxTradeRequest.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getTxTradeRequest.');
            }
            const localVarPath = `/tx/trade_request`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tradeId !== undefined) {
                localVarQueryParameter['tradeId'] = tradeId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TxApi - functional programming interface
 * @export
 */
export const TxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {string} estateId 
         * @param {number} perShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxDividend(estateId: string, perShare: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossTx>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).getTxDividend(estateId, perShare, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {number} tradeId 
         * @param {string} from 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxTradeRequest(tradeId: number, from: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossTx>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).getTxTradeRequest(tradeId, from, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TxApi - factory interface
 * @export
 */
export const TxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {string} estateId 
         * @param {number} perShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxDividend(estateId: string, perShare: number, options?: any): AxiosPromise<CrossTx> {
            return TxApiFp(configuration).getTxDividend(estateId, perShare, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a CrossTx to be signed
         * @param {number} tradeId 
         * @param {string} from 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxTradeRequest(tradeId: number, from: string, options?: any): AxiosPromise<CrossTx> {
            return TxApiFp(configuration).getTxTradeRequest(tradeId, from, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TxApi - object-oriented interface
 * @export
 * @class TxApi
 * @extends {BaseAPI}
 */
export class TxApi extends BaseAPI {
    /**
     * 
     * @summary get a CrossTx to be signed
     * @param {string} estateId 
     * @param {number} perShare 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public getTxDividend(estateId: string, perShare: number, options?: any) {
        return TxApiFp(this.configuration).getTxDividend(estateId, perShare, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a CrossTx to be signed
     * @param {number} tradeId 
     * @param {string} from 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public getTxTradeRequest(tradeId: number, from: string, options?: any) {
        return TxApiFp(this.configuration).getTxTradeRequest(tradeId, from, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get user information
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUser.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get user information
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUsers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary get user information
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): AxiosPromise<Array<User>> {
            return UserApiFp(configuration).getUsers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary get user information
     * @param {string} id user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(id: string, options?: any) {
        return UserApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(options?: any) {
        return UserApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }
}


